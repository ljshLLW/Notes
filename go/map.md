## Map  「go

### 如何声明一个Map

```go
m1 := map[int]int{1: 2, 2: 4, 3: 9}

m2 := map[int]int{}

m3 := make(map[int]int , 10)
```

​	上面三种方法都可以生成一个键为int类型值为int类型的map，第一种方法可以初始化这个map，第二种只是声明了map没初始化，第三种方法看起来就有点奇怪了，传入两个参数，第一个参数是map的类型，第二个是容量，map的容量是可变的，刚声明的时候比较小，随着键值对的不断增加，就需要扩容来装载更多的元素，扩容是一个比较消耗性能的操作，所以如果我们知道我们需要的map的大小，就可以在声明的时候确定容量，减少性能的损耗。

### 如何从Map中读取元素

```go
m1[1]
```

接上上边的第一个声明，这样来读取key为1的元素，因为是int作为key所以直接放入int值，如果是string作为key那就在[]放入string。

那读取不存在的数据会怎么样呢？

```go
println(m1[4])
//  0
```

得到的结果是0，那这里就有个疑问了，如果现在map m1中就有一对键值为4:0，那我该怎么判断4这个key 是有值呢还是没值呢，自然是有方法的

```go
if v, e := m1[4]; e {
  println(v)
} else {
  println("no")
}
```

e接收到一个布尔值，表示是否有值。

我们写java的时候经常会遇到空指针异常，取map中的一个不存在的键值对也会触发，go语言这样设计就避免了这个问题，但自我感觉半斤八两，可能是刚刚学习，没体会到其中妙用

### 如何遍历Map

```go
for k, v := range m1 {
  println(k, v)
}
```

简洁明了，有编程基础的理解起来不难。

### 可以存放函数的Map

go语言的Map的value可以放入函数，看起来像下面代码这样

```go
m := map[int]func(v int) int{}
m[1] = func(v int) int { return v }
m[2] = func(v int) int { return v * v }
println(m[1](2))
println(m[2](2))
```

这是其他编程语言不常见的特性。